{-# LANGUAGE TemplateHaskell, QuasiQuotes, TypeSynonymInstances, 
 GADTs, ExistentialQuantification, MultiParamTypeClasses, FlexibleInstances #-}
module Instances where
--import Data.Generic.Diff.TH2
import Data.Generic.Diff.Specialize
import Data.Generic.Diff
import Language.Haskell.TH
import Language.Haskell.TH.Universe    
import Data.Word
import Data.Aeson
--import Language.C
import Hdis86
import Language.ECMAScript3

type IntList = [Int]

data ListLike = ListLike
    {
        values :: IntList
    }
    deriving(Show, Eq)

data DoubleList = DoubleList 
    {
        values1 :: [Int],
        values2 :: ([Float], Double)
    }

data PolyTest a = PolyTest 
	{
		best :: [a]
	}

data UnpolyTest = UnpolyTest {
		unpoly :: PolyTest Char
	}

data TupleTest = TupleTest {
    tt :: (Int, Double)
}

data SubbedType a = SubbedType {
        subbedType :: PolyTest a
    }

newtype IntSubbedType = IntSubbedType (SubbedType Int)

newtype NullJ = NullJ (JavaScript ())
--
--makeGDiff ''IntSubbedType
--makeGDiff ''CTranslUnit
--makeGDiff ''Instruction
--makeGDiff ''NullJ

-- makeGDiff ''Value

--data Tree a = Leaf a | Node (Tree (a,a))

--newtype WordTree = WordTree (Tree Word32)

--makeGDiff ''WordTree

-- $(makeGDiff ''TupleTest)


$(do
    info <- reify ''IntSubbedType
    runIO $ print info    

--    univ <- getUniverse ''DoubleList
--    runIO $ print univ

    return [])


-- makeGDiff ''UnpolyTest
-- $(makeGDiff ''ListLike)
-- $(makeGDiff ''DoubleList)
-- $(makeGDiff ''Info)


{-
data DoubleListFamily a_a6qB b_a6qC
  = (a_a6qB ~ [Int], b_a6qC ~ Nil) => Nils_a6qf |
    (a_a6qB ~ [Int], b_a6qC ~ Cons Int (Cons [Int] Nil)) => Cons_a6qg |
    (a_a6qB ~ Int, b_a6qC ~ Nil) => Int_a6qh Int |
    (a_a6qB ~ [Float], b_a6qC ~ Nil) => Nils_a6qi |
    (a_a6qB ~ [Float], b_a6qC ~ Cons Float (Cons [Float] Nil)) =>
    Cons_a6qj |
    (a_a6qB ~ Float, b_a6qC ~ Nil) => Float_a6qk Float
instance Family DoubleListFamily where
  decEq Nils_a6qf Nils_a6qf = Just (Refl, Refl)
  decEq Cons_a6qg Cons_a6qg = Just (Refl, Refl)
  decEq (Int_a6qh x_a6ql) (Int_a6qh y_a6qm)
    = if (x_a6ql == y_a6qm) then Just (Refl, Refl) else Nothing
  decEq Nils_a6qi Nils_a6qi = Just (Refl, Refl)
  decEq Cons_a6qj Cons_a6qj = Just (Refl, Refl)
  decEq (Float_a6qk x_a6qn) (Float_a6qk y_a6qo)
    = if (x_a6qn == y_a6qo) then Just (Refl, Refl) else Nothing
  decEq _ _ = Nothing
  apply Nils_a6qf CNil = []
  apply Cons_a6qg (CCons x_a6qq (CCons x_a6qp CNil))
    = ((:)) x_a6qq x_a6qp
  apply (Int_a6qh x_a6qr) CNil = x_a6qr
  apply Nils_a6qi CNil = []
  apply Cons_a6qj (CCons x_a6qt (CCons x_a6qs CNil))
    = ((:)) x_a6qt x_a6qs
  apply (Float_a6qk x_a6qu) CNil = x_a6qu
  fields Nils_a6qf [] = Just CNil
  fields Cons_a6qg ((:) x_a6qv x_a6qw)
    = Just (CCons x_a6qv (CCons x_a6qw CNil))
  fields (Int_a6qh _) _ = Just CNil
  fields Nils_a6qi [] = Just CNil
  fields Cons_a6qj ((:) x_a6qx x_a6qy)
    = Just (CCons x_a6qx (CCons x_a6qy CNil))
  fields (Float_a6qk _) _ = Just CNil
  fields _ _ = Nothing
  string Nils_a6qf = "[]"
  string Cons_a6qg = ":"
  string (Int_a6qh p_a6qz) = show p_a6qz
  string Nils_a6qi = "[]"
  string Cons_a6qj = ":"
  string (Float_a6qk p_a6qA) = show p_a6qA
instance Data.Generic.Diff.Type DoubleListFamily [Int] where
  constructors = [Concr Nils_a6qf, Concr Cons_a6qg]
instance Data.Generic.Diff.Type DoubleListFamily Int where
  constructors = [Abstr Int_a6qh]
instance Data.Generic.Diff.Type DoubleListFamily [Float] where
  constructors = [Concr Nils_a6qi, Concr Cons_a6qj]
instance Data.Generic.Diff.Type DoubleListFamily Float where
  constructors = [Abstr Float_a6qk]
-}
